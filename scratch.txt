----------------------------------基于数组的序列的优点--------------------------------------------------
	数组提供了时间复杂度为O(1)的基于整数索引的元素访问方法。对于任何k值以时间复杂度O(1)访问第k个元素的能力是一个数组的优点。
相应地，在一个链表中定位第k个元素需要从链表初始位置开始遍历链表，时间复杂度为O(k)，如果是反向遍历双向链表，时间复杂度为O(n-k)。
	通常，具有等效边界的操作使用基于数组的结构运行一个常数因子比使用基于链表的结构运行更有效率。
例如，考虑基于数组的序列的一个典型的enqueue操作（代码段6-7ArrayQueue）。忽略调整数组大小的问题（resize），
ArrayQueue内这样一个操作包含一个新索引的计算，一个整数的增量，并在数组中为元素存储一个引用。
考虑一个基于链表的序列（LinkedQueue），这样的新增操作包括及诶点的实例化、节点的合适链接和整数的增量。
当新增操作在基于数组的序列中需要的时间复杂度是O(1)时，基于链表的序列的操作就需要更多CPU操作，特别是节点实例化。
	相较于链式结构，基于数组的序列使用存储的比例更少。因为链表需要存储节点的引用和指向下一个节点的引用。
基于链表的序列的优点
	基于链表的结构为他们的操作提供情况最坏的时间界限。这与动态数组的扩张和收缩相关联的摊销边界相对应。
当许多单个操作是一个大型计算的一部分时，我们仅关心计算的总时间，摊销边界和最坏情况的边界一样精确，因为它可以确定花费所有单个操作的时间总和。
但是，当数据结构操作用于一个实时系统，旨在提供更迅捷的反应（如操作系统、web服务器等），单（摊销）操作导致的长时间延迟可能有不利影响。
	基于链表的结构支持在任意位置进行时间复杂度为O(1)的插入和删除操作。例如，在文本编辑器中任意位置插入和删除操作（Person_List）
------------------------------------基于堆的优先级队列的分析----------------------------------------------
前言：
    已排序队列可以实现查找或者删除具有最小键值的元素的时间复杂度是O(1)，但是添加新元素操作的时间复杂度为O(n)
    未排序队列可以实现添加新元素操作的时间复杂度为O(1)，但是进行查找或者删除操作的时间复杂度是O(n)
堆的数据结构：基于数组的完全二叉树表示。存储在T中元素的索引f(p)是元素位置p的函数。
堆的特征：
    Heap-Order,节点p的元素大于等于其父母节点的元素大小。
    堆的高度h=log n, （log n向下取整）
堆的特征的应用：因为其高度是对数，因此与高度成比例的操作的时间复杂度都是对数级别的！！！！！
堆T由n个节点，每个节点存储一个键值对的引用
由于堆T是完全二叉树，所以堆T的高度就是O(log n)
由于根部包含最小元组，因此min操作的时间复杂度是O(1)
add和remove_min方法中需要定位堆的最后一个位置，在基于数组表示的堆上（该位置索引是n-1）需要的时间复杂度为O(1)，在基于链表的堆上需要O(log n)
堆向上冒泡和向下冒泡执行交换的次数在最坏的情况下等于堆T的高度
